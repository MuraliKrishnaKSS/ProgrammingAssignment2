skip()
t4 <-strptime(t3, "%B %d, %Y %h:%M")
t4 <-strptime(t3, "%B %d, %Y %H:%M")
t4
class(t4)
Sys.time()>t1
Sys.time()-t1
difftime(Sys.time(), t1, units='days')
Sys.Date()
mean(c(2,4,5))
submit()
boring_function('My first function!')
boring_function
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11,5)
remander(divisor = 11, num = 5)
remainder(divisor = 11, num = 5)
remainder(4, div=2)
args(remainder)
submit()
evaluate(sd,c(1.4,3.6,7.9,8.8))
evaluate(function(x) {x+1}, 6)
evaluate(function(x) {x[1]}, c(8,4,0))
evaluate(function(x) {x[3]}, c(8,4,0))
evaluate(function(x) {x[length(x)]}, c(8,4,0))
?paste
paste("Programming", "is", "fun!")
submit()
telegram("How do you do")
submit()
mad_libs(place="India", adjective="very good", noun ="Mr X")
submit()
"I" %p% "love" %p% "R!"
?lapply
x<-list.files(Directory="D:/DataScience/specdata",pattern="*.csv")
x<-list.files("D:/DataScience/specdata",pattern="*.csv")
x
library(swirl)
swirl()
head(flags)
dim(flags)
class(flags)
cls_list <- lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect(flags,class)
cls_vect <- sapply(flags,class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[,11:17]
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes  <- flags[,19:23]
lapply(flag_shapes,range)
shape_mat <- sapply(flag_shapes,range)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals <- lapply(flags,unique)
unique_vals
sapply(unique_vlas,length)
sapply(unique_vals,length)
sapply(flags,unique)
lapply(unique_vals,function(elem) elem[2])
sapply(flags,unique)
vapply(flags,unique,numeric(1))
ok()
sapply(flags,class)
vapply(flags,class,character(1))
?tapply
table(flags$landmass)
table(flag$animate)
table(flags$animate)
tapply(flags$animate,flags$landmass,mean)
tapply(flags$population,flags$red,summary)
tapply(flags$population,flags$landmass,summary)
sapply(flags,unique)
vapply(flags,unique,numeric(1))
ok()
sapply(flags,class)
vapply(flags,class,character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate,flags$landmass,mean)
tapply(flags$polulation,flags$red,summary)
tapply(flags$population,flags$red,summary)
tapply(flags$population,flags$landmass,summary)
library(datasets)
data("iris")
?iris
rm(list=ls(all=TRUE))
data("iris")
q()
ls
debug(ls)
ls
ls()
fq
q
undebug(ls)
q
undebug(ls)
undebug(ls)
ls
ls()
debug(ls)
ls
ls()
undebug(ls)
undebug(ls)
?round
round(0.5)
library(datasets)
data("iris")
tapply(iris$Sepal.Length,iris$Species,mean)
x<- tapply(iris$Sepal.Length,iris$Species,mean)
x[3]
round(x[3])
apply(iris[,1:4],2,mean)
data(mtcars)
tapply(mtcars$hp,mtcars$cyl,mean)
x<- tapply(mtcars$hp,mtcars$cyl,mean)
round(x[3]-x[1])
debug(ls)
ls()
undebug(ls)
q
undebug(ls)
pwd
ls
pwd()
q()
pwd
pwd()
/
help()
ls
ls()
pwd()
q()
getwd()
dir
dir()
cd ProgrammingAssignment2
getwd()
setwd(C:/users/KSSMK/ProgrammingAssignment2)
setwd("C:/users/KSSMK/ProgrammingAssignment2")
dir
dir()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
x<-c(2,3,4,5)
makevector(x)
makeVector(x)
makeVector(x)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(x)
cachemean(makeVector(x))
cachemean(makeVector)
cachemean(makeVector(x))
makeVector
makeVector[4]
makeVector["getmean"]
cachemean(makeVector(x))
makeVector$getmean
makeVector$getmean()
ls
ls()
cachemean(x
)
cachemean(makeVector,x)
cachemean(makeVector(),x)
makeVector$get()
makeVector$get() x
a<-matrix(nrow=1,ncol=1)
a
class(a)
b<-1
class(b)
c <-matrix()
class(c)
d <-NULL
c <-d
c
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse_val) m <<- inverse_val
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
x
x <- matrix(nrow=3,ncol=3)
x <- matrix(1:9,nrow=3,ncol=3)
x
cacheSolve(makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve(makeCacheMatrix(x))
debug(cacheSolve)
cacheSolve(makeCacheMatrix(x))
function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
undebug(cacheSolve)
cacheSolve(makeCacheMatrix(x))
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x))
rm(list=ls(all=TRUE))
x <- matrix(1:9,nrow=3,ncol=3)
solve(x)
x
x[3,3] <-13
x
solve(x)
cacheSolve(makeCacheMatrix(x))
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve(makeCacheMatrix(x))
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
cacheSolve(makeCacheMatrix(x))
mat <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
mat
cacheSolve(makeCacheMatrix(mat))
z<-cacheSolve(makeCacheMatrix(mat))
mat * z
rm(list=ls(all=TRUE))
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
a<- matrix(1:25, nrow=5, ncol=5)
a
cacheSolve(makeCacheMatrix(a))
a[5,5] <-33
a <- matrix(nrow=3,ncol=3)
a
a <- matrix(nrow=2,ncol=2)
a <- matrix(1:4,nrow=2,ncol=2)
cacheSolve(makeCacheMatrix(a))
b<-cacheSolve(makeCacheMatrix(a))
a * b
b
a[1,1] <- 4
a[2,1] <- 2
a[1,2] <- 7
a[2,2] <- 6
a
b<-cacheSolve(makeCacheMatrix(a))
b
a %*% b
a <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
b<-cacheSolve(makeCacheMatrix(a))
a %*% b
a<-matrix(nrow=3,ncol=3)
a[1,1] <- 0
a[2,1] <- 2
a[3,1] <- 3
a[1,2] <- 2
a[1,3] <- 4
a[2,2] <- 4
a[2,3] <- 2
a[3,2] <- 3
a[3,3] <- 1
a
b<-cacheSolve(makeCacheMatrix(a))
b
a %*% b
a <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
b<-cacheSolve(makeCacheMatrix(a))
b
a %*% b
c<a %*% b
c<- a %*% b
c[1,1]
c[1,2]
c[1000,1000]
c[100,100]
c[10,10]
c[27,10]
c[27,27]
det(c)
p <- det(a)
q <- det(b)
p
q
a<-matrix[nrow=2, ncol=3]
a<-matrix[nrow=2, ncol=2]
a<-matrix(nrow=2, ncol=20
)
a<-matrix(nrow=2, ncol=2)
a[1,1] <-1
a[2,1] <-5
a[2,2] <-6
a[1,2] <-2
a
det(a)
b<-cacheSolve(makeCacheMatrix(a))
b
det(b)
det(a) * det(b)
a <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
b<-cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
sample()
?sample
a <- matrix(rnorm(100,nrow=10,ncol=10))
a <- matrix(rnorm(100),nrow=10,ncol=10)
b<-cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
b
det(b)
det(a)
a %*% b
p <-det(a)
q <-det(b)
p*q
rm(list=ls(all=TRUE))
source("cachematrix.R")
x <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
rm(x)
a <- matrix(rnorm(1e6),nrow=1e3,ncol=1e3)
cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
b< -cacheSolve(makeCacheMatrix(a))
b <- cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
rm(list=ls(all=TRUE))
rm(list=ls(all=TRUE))
? rnorm
? sample
a <- matrix(sample(1:50000000,1000000),nrow=1000,ncol=1000)
source("cachematrix.R")
b <- cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
rm(x)
rm(a)
rm(b)
a <- matrix(sample(1:50000000,10000),nrow=100,ncol=100)
b <- cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
rm(a)
rm(b)
a <- matrix(sample(1:50000,10000),nrow=100,ncol=100)
b <- cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
get <-function() a
z < get()
z <- get()
z
b <- cacheSolve(makeCacheMatrix,a)
b <- cacheSolve(makeCacheMatrix(a))
m <- NULL
b <- cacheSolve(makeCacheMatrix(a))
det(a) * det(b)
m
rm(list=ls(all=TRUE))
tmakeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(x) m <<- solve(x)
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
tcacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
n <- x$getinverse()
if(!is.null(n)) {
message("getting cached data")
return(n)
}
data <- x$get()
x$setinverse(data)
return(m)
}
a <- matrix(25:1,nrow=3,ncol=3)
a <- matrix(sample(25:1,9),nrow=3,ncol=3)
a
b <- tcacheSolve(tmakeCacheMatrix(a))
